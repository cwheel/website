{
	"projects" : [
		{
			"title"        : "imccelerate",
		 	"tagline"      : "Real time image acceleration, caching and CDN offloading",
		 	"builtWith"    : "Node, Express, Microsoft Oxford and Microsoft Azure CDN",
		 	"builtFor"     : "HackRPI, Fall 2015",
		 	"sourceCode"   : "https://github.com/cwheel/imccelerate",
		 	"special"      : "Runner Up (Second Place) in Web Applications",
		 	"accent"       : "#aeda00",
		 	"banner"       : "/res/projects/imccelerate/thumb.jpg",
		 	"screen1"      : "/res/projects/imccelerate/screen1.jpg",
		 	"screen2"      : "/res/projects/imccelerate/screen2.jpg",
		 	"screen3"      : "/res/projects/imccelerate/screen3.jpg",
		 	"description"  : "After working with the web for long enough, I realized that there seemed to be little done regarding the large amount of bandwidth required to load an image, and the detrimental effectr it has on page load performance. To solve this, we built a piece of Express middleware, imccelerate. Imccelerate intercepts all GET requests and inspects them for known image types. If imccelerate detects a request for an image, it will then scale the image appropriately based on the users screen resolution and screen density. Then, the resulting image is dropped into an LRU cache to let others with the same device and or screen enjoy a massive speed boost in page load time, up to 90% faster with 90% less bandwidth consumed in some of cases. Furthermore, imccelerate features a proper image sizing system. Why request a massive, page filling image if its just for a thumbnail? We took a cue from Bootstrap (and their sizing convention) and added a variety of relative sizes ranging from extra small to extra large. These sizes can seamlessly be appended to each image request. Even better, some of our sizes feature vision logic from Microsoft Oxford to ensure they look their best. What happens if you take a 4K image and scale it down to a profile picture? Well, usually nothing good. We added a profile size just for cases like this. Prior to delivering and caching the image, we ship the resource off to Microsoft Oxford and request that the image be bounded to a face, ensuring nobody ever gets cut off. Finally, we attempted to solve one last issue. What happens if a site comes under heavy load and still needs to deliver its largest and most bandwidth intense resources? Send them somwhere that can handle the load! We built a dynamic CDN offloading system. If an image resource becomes too heavily requested to continue its successful delivery, imccelerate will offload the image to Azures high powered content delivery network and seamlessly move future clients to it, all without any interruption in service. When the resource becomes less requested in the future, it will drop out of the cache and future clients will initiate the process over again."
		},
		{
			"title"        : "Familee",
		 	"tagline"      : "Wellness for the ones you care about",
		 	"builtWith"    : "Mongo, Node, Angular, Express and the Fitbit API",
		 	"builtFor"     : "HackUMass, Fall 2015",
		 	"sourceCode"   : "https://github.com/cwheel/Familee",
		 	"special"      : "Winner of Fitbit's 'Best Use of Fitbit API' award",
		 	"accent"       : "#fc5830",
		 	"banner"       : "/res/projects/familee/thumb.jpg",
		 	"screen1"      : "/res/projects/familee/screen1.png",
		 	"screen2"      : "/res/projects/familee/screen2.png",
		 	"screen3"      : "/res/projects/familee/screen3.png",
		 	"description"  : "Wellness for the ones you care about, in a beautiful and elegant web app. Familee, I and my teammates HackUMass 2015 submission, pulls data from connected Fitbit devices to keep relatives, care givers and family members informed about their older loved ones health. Familee looks at time spent walking, sleeping, and heard rate each day. Familee also attempts to infer when a love one is sick by combining all three data points into one, a 'sickness score'. Additionally, Familee uses Twilio to send text message alerts when it senses troubling health statistics. To top it off, Familee also supports texting medication reminders at pre determined times during the day."
		},
		{
			"title"        : "WiZer",
		 	"tagline"      : "Smarter Wireless Insights",
		 	"builtWith"    : "Mongo, Node, Angular, Express, Python, Intel Edison and Rasberry Pi",
		 	"builtFor"     : "HackUMass, Spring 2015",
		 	"sourceCode"   : "https://github.com/cwheel/wizer",
		 	"special"      : "Finalist",
		 	"accent"       : "#3e51b5",
		 	"banner"       : "/res/projects/wizer/thumb.jpg",
		 	"screen1"      : "/res/projects/wizer/screen1.jpg",
		 	"screen2"      : "/res/projects/wizer/screen2.jpg",
		 	"screen3"      : "/res/projects/wizer/screen3.jpg",
		 	"description"  : "The wireless in our residence hall is often plagued by rouge devices like wireless printers, Chromecasts, personal hotspots and other interfering devices. Even worse, areas of our building have a poor wireless signal overall regardless of the areas devices. We've spent a great number of hours roaming our hall with laptops and phones, staring at ugly text based tables searching for devices and checking signal strength. We wanted to deploy devices that could do the job we couldn't; to monitor the hall and its networks (or any area for that matter) 24/7 and look through the data at our leisure, so we built WiZer. WiZer works by connecting to microcontroller based devices such as the Intel Edison and Rasberry Pi that run a custom python application. The application reports the wireless networks and a multitude of information about them to a central machine running a WiZer instance. WiZer then cleans up the information and stores it in MongoDB, keeping it at the ready for searching and future analyzation. WiZer features a beautiful web based client that allows for easy network searching, rouge device detection, network monitoring, wireless channel analysis and wireless history storage; all with the luxury of never leaving your desk."
		}
	]
}