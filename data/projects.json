{
	"projects" : [
		{
			"title"        : "imccelerate",
		 	"tagline"      : "Real time image acceleration, caching and CDN offloading",
		 	"builtWith"    : "Node, Express, Microsoft Oxford and Microsoft Azure CDN",
		 	"builtFor"     : "HackRPI, Fall 2015",
		 	"sourceCode"   : "https://github.com/cwheel/imccelerate",
		 	"special"      : "Runner Up (Second Place) in Web Applications",
		 	"accent"       : "#aeda00",
		 	"banner"       : "/res/projects/imccelerate/thumb.jpg",
		 	"screen1"      : "/res/projects/imccelerate/screen1.jpg",
		 	"screen2"      : "/res/projects/imccelerate/screen2.jpg",
		 	"screen3"      : "/res/projects/imccelerate/screen3.jpg",
		 	"timeTitle"     : true,
		 	"description"  : "After working with the web for long enough, I realized that there seemed to be little done regarding the large amount of bandwidth required to load an image, and the detrimental effectr it has on page load performance. To solve this, we built a piece of Express middleware, imccelerate. Imccelerate intercepts all GET requests and inspects them for known image types. If imccelerate detects a request for an image, it will then scale the image appropriately based on the users screen resolution and screen density. Then, the resulting image is dropped into an LRU cache to let others with the same device and or screen enjoy a massive speed boost in page load time, up to 90% faster with 90% less bandwidth consumed in some of cases. Furthermore, imccelerate features a proper image sizing system. Why request a massive, page filling image if its just for a thumbnail? We took a cue from Bootstrap (and their sizing convention) and added a variety of relative sizes ranging from extra small to extra large. These sizes can seamlessly be appended to each image request. Even better, some of our sizes feature vision logic from Microsoft Oxford to ensure they look their best. What happens if you take a 4K image and scale it down to a profile picture? Well, usually nothing good. We added a profile size just for cases like this. Prior to delivering and caching the image, we ship the resource off to Microsoft Oxford and request that the image be bounded to a face, ensuring nobody ever gets cut off. Finally, we attempted to solve one last issue. What happens if a site comes under heavy load and still needs to deliver its largest and most bandwidth intense resources? Send them somwhere that can handle the load! We built a dynamic CDN offloading system. If an image resource becomes too heavily requested to continue its successful delivery, imccelerate will offload the image to Azures high powered content delivery network and seamlessly move future clients to it, all without any interruption in service. When the resource becomes less requested in the future, it will drop out of the cache and future clients will initiate the process over again."
		},
		{
			"title"        : "Familee",
		 	"tagline"      : "Wellness for the ones you care about",
		 	"builtWith"    : "Mongo, Node, Angular, Express and the Fitbit API",
		 	"builtFor"     : "HackUMass, Fall 2015",
		 	"sourceCode"   : "https://github.com/cwheel/Familee",
		 	"special"      : "Winner of Fitbit's 'Best Use of Fitbit API' award",
		 	"accent"       : "#fc5830",
		 	"banner"       : "/res/projects/familee/thumb.jpg",
		 	"screen1"      : "/res/projects/familee/screen1.png",
		 	"screen2"      : "/res/projects/familee/screen2.png",
		 	"screen3"      : "/res/projects/familee/screen3.png",
		 	"timeTitle"     : true,
		 	"description"  : "Wellness for the ones you care about, in a beautiful and elegant web app. Familee, I and my teammates HackUMass 2015 submission, pulls data from connected Fitbit devices to keep relatives, care givers and family members informed about their older loved ones health. Familee looks at time spent walking, sleeping, and heard rate each day. Familee also attempts to infer when a love one is sick by combining all three data points into one, a 'sickness score'. Additionally, Familee uses Twilio to send text message alerts when it senses troubling health statistics. To top it off, Familee also supports texting medication reminders at pre determined times during the day."
		},
		{
			"title"        : "WiZer",
		 	"tagline"      : "Smarter Wireless Insights",
		 	"builtWith"    : "Mongo, Node, Angular, Express, Python, Intel Edison and Rasberry Pi",
		 	"builtFor"     : "HackUMass, Spring 2015",
		 	"sourceCode"   : "https://github.com/cwheel/wizer",
		 	"special"      : "Finalist",
		 	"accent"       : "#3e51b5",
		 	"banner"       : "/res/projects/wizer/thumb.jpg",
		 	"screen1"      : "/res/projects/wizer/screen1.jpg",
		 	"screen2"      : "/res/projects/wizer/screen2.jpg",
		 	"screen3"      : "/res/projects/wizer/screen3.jpg",
		 	"timeTitle"     : true,
		 	"description"  : "The wireless in our residence hall is often plagued by rouge devices like wireless printers, Chromecasts, personal hotspots and other interfering devices. Even worse, areas of our building have a poor wireless signal overall regardless of the areas devices. We've spent a great number of hours roaming our hall with laptops and phones, staring at ugly text based tables searching for devices and checking signal strength. We wanted to deploy devices that could do the job we couldn't; to monitor the hall and its networks (or any area for that matter) 24/7 and look through the data at our leisure, so we built WiZer. WiZer works by connecting to microcontroller based devices such as the Intel Edison and Rasberry Pi that run a custom python application. The application reports the wireless networks and a multitude of information about them to a central machine running a WiZer instance. WiZer then cleans up the information and stores it in MongoDB, keeping it at the ready for searching and future analyzation. WiZer features a beautiful web based client that allows for easy network searching, rouge device detection, network monitoring, wireless channel analysis and wireless history storage; all with the luxury of never leaving your desk."
		},
		{
			"title"        : "Sprox",
		 	"tagline"      : "Beautiful Information for Students",
		 	"builtWith"    : "Mongo, Node, Angular, Express, SpookyJS",
		 	"builtFor"     : "Fall 2014",
		 	"sourceCode"   : "https://github.com/cwheel/sprox",
		 	"special"      : "",
		 	"accent"       : "#7f7f7f",
		 	"banner"       : "/res/projects/sprox/thumb.jpg",
		 	"screen1"      : "/res/projects/sprox/screen1.jpg",
		 	"screen2"      : "/res/projects/sprox/screen2.jpg",
		 	"screen3"      : "/res/projects/sprox/screen3.jpg",
		 	"timeTitle"     : false,
		 	"description"  : "The information available to students at my University is great, despite being a bit fragmented across a plethora of websites with varying quality and design. Sprox was our prototype of a better system. We built an interface thats elegant yet functional, easy to use and provides only the data students want. Sprox aggregates student data via SpookyJS and keeps discovered data in a MongoDB instance. Sprox shows students their class schedule, housing information, parking permits, campus maps, student debit account funds and dining statistics."
		},
		{
			"title"        : "RocketShip",
		 	"tagline"      : "Shortcuts, Shortcuts for Everything",
		 	"builtWith"    : "Cocoa with just a touch of Carbon",
		 	"builtFor"     : "Summer 2012",
		 	"sourceCode"   : "https://github.com/cwheel/wizer",
		 	"special"      : "",
		 	"accent"       : "#af0000",
		 	"banner"       : "/res/projects/rocketship/thumb.jpg",
		 	"screen1"      : "/res/projects/rocketship/screen1.jpg",
		 	"screen2"      : "/res/projects/rocketship/screen2.jpg",
		 	"screen3"      : "/res/projects/rocketship/screen3.jpg",
		 	"timeTitle"     : false,
		 	"description"  : "Shortly after the Mac App store was released into the wild, I built RocketShip. RocketShip did what I wanted but could never find on OS X, good, reliable keyboard shortcuts. I built a series of hook-able actions that could be triggered by custom shortcuts. These shortcuts were then managed in the background by RocketShip. I delved fairly deep into Objective-C and even a bit of Carbon (for shortcut event handling). After building RocketShip, I released it on the Mac App store for $1.99. RocketShip was the first piece of software I had ever built for sale and did quite well for something I built while only a sophomore in high school. Built for OS X 10.6 through 10.8."
		},
		{
			"title"        : "Tenjin 2",
		 	"tagline"      : "Information and lighting with just a touch",
		 	"builtWith"    : "Mongo, Node, Angular, Express, Java, Arduino, Android SDK",
		 	"builtFor"     : "Summer 2015",
		 	"sourceCode"   : "https://github.com/cwheel/tenjin-2",
		 	"special"      : "",
		 	"accent"       : "#9544d3",
		 	"banner"       : "/res/projects/tenjin/thumb.jpg",
		 	"screen1"      : "/res/projects/tenjin/screen1.jpg",
		 	"screen2"      : "/res/projects/tenjin/screen2.jpg",
		 	"screen3"      : "/res/projects/tenjin/screen3.jpg",
		 	"timeTitle"     : false,
		 	"description"  : "Tenjin is an elegant room lighting and information system designed with UMass Amherst in mind. We started Tenjin with a simple goal in mind: to bring our simple dorm room into the modern era. The first version of Tenjin supported only a simple informational screen with NPR news, current weather, and some of our favorite sub-Reddits among others. During the summer of our second year, we embarked on Tenjin 2, a complete rebuild of Tenjin in NodeJS. Not only does Tenjin 2 provided its classic information screen (now with support for 1080p monitors and proper scaling), but it also supports controlling LED strips for beautiful and elegant room lighting. I constructed a custom lighting circuit with three channels that operate over standard ethernet cable and connect to modified LED lighting strips with ethernet jacks attached. Each cable is capable of controlling a red, green, blue and white channel. Additionally, the entire system can be controlled remotely via an Android application."
		}
	]
}